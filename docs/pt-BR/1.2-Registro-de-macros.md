# Registro de Macros

O Luminix permite a adição de macros personalizadas, inspiradas nos hooks do WordPress. Isso permite que você adicione funcionalidades personalizadas ao sistema, e também estenda as funcionalidades existentes. As macros são registradas através dos métodos do container `Macro`.

```javascript
app().boot({
    macros: ({ macro }) => {
        macro.addFilter(
            'model_user_get_first_name_attribute',
            (value, user) => user.attributes.name.split(' ')[0]
        )
    }
}).then(({ auth }) => {
    if (auth.check()) {
        console.log(`Bem vindo, ${auth.user().firstName}`);
    }
});
```

O exemplo acima adiciona uma macro que é análoga ao *accessor* `getFirstNameAttribute` do Laravel, sendo executada no frontend. A macro é registrada através do método `addFilter` do container `Macro`. O primeiro argumento é o nome da macro, e o segundo é a função que será executada e retornará o valor modificado.

Recomenda-se que você registre suas macros em um arquivo separado, e as importe no arquivo principal de inicialização. Isso permite que você mantenha suas macros organizadas e facilmente acessíveis:

```javascript
// macros.js
export default ({ macro }) => {
    macro.addFilter(
        'model_user_get_first_name_attribute',
        (value, user) => user.attributes.name.split(' ')[0]
    );
}
```

```javascript
// main.js
import { app } from '@luminix/core';
import myMacros from './macros';

app().boot({
    macros: myMacros
}).then(({ auth }) => {
    if (auth.check()) {
        console.log(`Bem vindo, ${auth.user().firstName}`);
    }
});
```

## Macros Disponíveis

### Filtros

Filtros são macros que processam um valor de entrada e retornam um valor de saída. Boa parte das personalizações de comportamentos do Luminix CMS são feitas através de filtros. A aplicação e os plugins podem adicionar filtros para modificar o comportamento de funções e métodos do sistema.

Preferencialmente, os filtros devem ser funções puras, ou seja, que não alteram o estado de variáveis externas. Isso garante que o comportamento do sistema seja previsível e consistente. Crie sempre um novo valor, ao invés de modificar o valor de entrada. É importante também que os filtros sempre retornem um valor, mesmo que seja o valor de entrada.

#### `model_{model}_call_{method}`

Executado quando registrado, ao tentar acessar a propriedade `{method}` de um modelo. O primeiro argumento é a função original, e o segundo argumento é o modelo. Este filtro deverá retornar uma função que será executada no lugar da função original.

Exemplo:

```javascript
import axios from 'axios';

macro.addFilter(
    'model_user_call_send_notification',
    (_original, user) => {
        return (notification) => axios.post('/api/notify', {
            user: user.id,
            message: notification
        });
    }
);

// ---
user.sendNotification('Hello, world!').then(() => {
    console.log('Notificação enviada!');
});
```

#### `model_{model}_get_{attribute}_attribute`

Executado quando um atributo de um modelo é acessado. O primeiro argumento é o valor do atributo, e o segundo é a instância do modelo.

Exemplo:

```javascript
macro.addFilter(
    'model_user_get_first_name_attribute',
    (value, user) => {
        if (typeof user.attributes.name !== 'string') {
            return null;
        }
        if (user.attributes.name.includes(' ')) {
            return user.attributes.name.split(' ')[0];
        }
        return user.attributes.name;
    }
);

// ---
console.log((new User({ name: 'John Doe' })).firstName); // John
```

#### `model_{model}_set_{attribute}_attribute`

Executado quando um atributo de um modelo é definido. O primeiro argumento é o valor que será definido, e o segundo é a instância do modelo.

Exemplo:

```javascript
import _ from lodash;

macro.addFilter(
    'model_user_set_name_attribute',
    (value, user) => {
        return _.upperFirst(value);
    }
);

// ---
const user = new User();
user.name = 'john doe';
console.log(user.name); // John Doe
```

#### `route_without_replace`

Modifica o comportamento do helper `route()` quando a rota tem parâmetros e é chamada sem substituir os parâmetros. Recebe a rota original como argumento, e deve retornar a rota modificada. É útil para criar integração entre a convenção de rotas do Laravel e de outros sistemas, por exemplo o React Router.

Exemplo:

```javascript

macro.addFilter(
    'route_without_replace',
    (route) => {
        // Remove leading and trailing slashes
        const newRoute = url.replace(/^\/|\/$/g, '');

        return `/${newRoute.replace(/{([^}]+)}/g, ':$1')}`;
    }
);

// ---
console.log(route('luminix.user.item')); // /api/users/:id
```

### Ações

Ações são macros que executam uma tarefa específica, e não retornam um valor. Elas são úteis para adicionar funcionalidades ao sistema, ou para modificar o comportamento de funções e métodos.

#### `model_{model}_save_success`

Executado após um modelo ser salvo com sucesso. O primeiro argumento é o modelo que foi salvo.

Exemplo:

```javascript
macro.addFilter(
    'model_user_save_success',
    (user) => {
        console.log(`Usuário ${user.name} salvo com sucesso!`);
    }
);
```

#### `model_{model}_save_error`

Executado após um modelo falhar ao ser salvo. O primeiro argumento é o erro que ocorreu, e o segundo é o modelo que falhou.

Exemplo:

```javascript
macro.addFilter(
    'model_user_save_error',
    (error, user) => {
        console.error(`Erro ao salvar usuário ${user.name}: ${error.message}`);
    }
);
```

#### `model_{model}_delete_success`

Executado após um modelo ser deletado com sucesso. O primeiro argumento é o modelo que foi deletado.

Exemplo:

```javascript
macro.addFilter(
    'model_user_delete_success',
    (user) => {
        console.log(`Usuário ${user.name} deletado com sucesso!`);
    }
);
```

#### `model_{model}_delete_error`

Executado após um modelo falhar ao ser deletado. O primeiro argumento é o erro que ocorreu, e o segundo é o modelo que falhou.

Exemplo:

```javascript
macro.addFilter(
    'model_user_delete_error',
    (error, user) => {
        console.error(`Erro ao deletar usuário ${user.name}: ${error.message}`);
    }
);
```

#### `model_{model}_force_delete_success`

Executado após um modelo ser deletado permanentemente com sucesso. O primeiro argumento é o modelo que foi deletado.

Exemplo:

```javascript
macro.addFilter(
    'model_user_force_delete_success',
    (user) => {
        console.log(`Usuário ${user.name} deletado permanentemente com sucesso!`);
    }
);
```

#### `model_{model}_force_delete_error`

Executado após um modelo falhar ao ser deletado permanentemente. O primeiro argumento é o erro que ocorreu, e o segundo é o modelo que falhou.

Exemplo:

```javascript
macro.addFilter(
    'model_user_force_delete_error',
    (error, user) => {
        console.error(`Erro ao deletar permanentemente usuário ${user.name}: ${error.message}`);
    }
);
```

#### `model_{model}_restore_success`

Executado após um modelo ser restaurado com sucesso. O primeiro argumento é o modelo que foi restaurado.

Exemplo:

```javascript
macro.addFilter(
    'model_user_restore_success',
    (user) => {
        console.log(`Usuário ${user.name} restaurado com sucesso!`);
    }
);
```

#### `model_{model}_restore_error`

Executado após um modelo falhar ao ser restaurado. O primeiro argumento é o erro que ocorreu, e o segundo é o modelo que falhou.

Exemplo:

```javascript
macro.addFilter(
    'model_user_restore_error',
    (error, user) => {
        console.error(`Erro ao restaurar usuário ${user.name}: ${error.message}`);
    }
);
```




